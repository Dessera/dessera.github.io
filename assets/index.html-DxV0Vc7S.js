import{_ as t,c as i,a as d,o as l}from"./app-BYecpAAQ.js";const o={};function c(a,e){return l(),i("div",null,e[0]||(e[0]=[d('<h2 id="进程、线程与协程" tabindex="-1"><a class="header-anchor" href="#进程、线程与协程"><span>进程、线程与协程</span></a></h2><table><thead><tr><th></th><th>进程</th><th>线程</th><th>协程</th></tr></thead><tbody><tr><td>描述</td><td>资源分配的最小单位</td><td>操作系统调度的最小单位</td><td>用户态的轻量线程</td></tr><tr><td>切换对象</td><td>寄存器、内核栈、页表、文件描述符</td><td>寄存器，内核栈</td><td>寄存器，函数栈</td></tr><tr><td>切换者</td><td>操作系统</td><td>操作系统</td><td>用户</td></tr><tr><td>并发</td><td>单个CPU上通过切换实现并发，在不同的CPU上调度实现并行</td><td>单个进程内的线程并发执行</td><td>同时只能有一个协程运行</td></tr><tr><td>通信</td><td>依靠操作系统</td><td>读写进程数据段或堆栈</td><td>读写进程数据段或堆栈</td></tr></tbody></table><ul><li>Linux线程：轻量级的进程，与进程同样以task_struct结构体的形式保存，线程栈的大小默认是8M，最大线程数一般受制于虚拟空间大小</li><li>线程回收： <ul><li>等待线程结束（<code>pthread_join</code>）</li><li>直接结束线程（<code>pthread_exit</code>），分离</li><li>让线程自己管理自己的资源（<code>pthread_detach</code>）</li></ul></li><li>进程的创建（<code>fork</code>）：内部调用<code>kernel_copy</code>，简单来说是复制了当前的的任务结构体作为新的进程</li><li>进程的退出（<code>exit/_exit/exit_group</code>）： <ul><li><code>_exit</code>：立即进入内核，无条件终止进程</li><li><code>exit</code>：在<code>_exit</code>前会刷新所有流（清空缓冲），这也是为什么如果子进程（没有<code>exec</code>）调用了<code>exit</code>，父进程就无法使用文件，Linux中，<code>_exit</code>实际上是<code>exit_group</code>的封装</li></ul></li><li>进程调度的简单过程：用户态 -&gt; 中断 -&gt; 内核态 -&gt; 替换<code>task_struct</code> -&gt; 设置页表、文件描述符等资源 -&gt; 切换栈 -&gt; 中断 -&gt; 用户态</li><li>进程调度算法： <ul><li>先来先服务（FCFS）</li><li>短作业优先（SJF，不能实现）</li><li>最短剩余时间优先（SRTN，不能实现）</li><li>时间片轮转（RR）抢占式</li><li>优先级调度</li><li>多级反馈队列：按照不同的时间片（优先级，比如第一级8ms，第二级16ms，etc.）分组任务，如果任务在当前队列没有执行完成，就被移动到下一级队列，只有上一级队列没有人在排队，下一级才会被调度</li><li>CFS：记录每个进程的运行时间（<code>vruntime</code>），总是选择<code>vruntime</code>最小的进程运行，优先级越高，<code>vruntime</code>增长速度越慢</li><li>O(1)调度：从优先级队列的最高优先级中找到进程调度（FIFO）</li></ul></li><li>进程通信： <ul><li>管道（<code>pipe</code>）：半双工（可能考虑父子进程都使用rw文件，但是一般来说，我觉得是单工） <ul><li>无名管道（内存文件）：父子进程之间使用</li><li>有名管道（FIFO文件，借助文件系统）：允许在没有亲缘关系的进程间使用</li></ul></li><li>共享内存：由一个进程创建，但多个进程都可以访问，最快的方式，要与信号量配合使用（通知内存变化）</li><li>消息队列：由操作系统维护的消息链表</li><li>信号：通知进程某事发生，比如<code>SIGABRT</code>、<code>SIGTERM</code>等</li><li>信号量：计数器，控制多个进程对共享资源的访问</li><li>套接字：利用网络进行进程间通信</li></ul></li><li>进程状态： <ul><li>NEW：新建</li><li>READY：可以被调度</li><li>RUNNING：正在或即将运行</li><li>WAITING：等待加入调度（IO或者等待其他进程）</li><li>EXIT：退出</li></ul></li><li>Linux特殊进程： <ul><li>守护进程：后台运行的，没有和终端相连的进程，创建守护进程要创建子进程，并退出父进程，在子进程中新建会话，再创建孙进程，子进程退出时，这个孙进程就是不属于原终端的进程了（还需要改变文件权限掩码、重置根目录等）。</li><li>孤儿进程：父进程先退出，子进程会由<code>init</code>收养</li><li>僵尸进程：子进程退出，父进程没有等待，子进程一直等待父进程<code>wait</code>，无法真正退出</li></ul></li><li>C/C++程序的编译到运行 <ul><li>预处理</li><li>编译（to asm）</li><li>汇编（to obj）</li><li>链接（to elf64） <ul><li>静态链接就是把预编译好的目标文件一同链接</li><li>动态链接已经生成的二进制文件，链接时会检查符号，并设置GOT和PLT的结构</li></ul></li><li>运行时，装载器（<code>ld-linux.so</code>）解析二进制文件（elf64）加载到内存空间，动态库以文件映射的方式加载进入内存空间，动态修改GOT表，将变量符号安排到正确的内存地址，当外部函数调用到来时，PLT表跳转到GOT表对应位置，调用装载器初始化正确的函数地址，然后跳转到该函数（可以加快载入时间，延迟初始化）</li></ul></li><li>同步原语 <ul><li>测试并设置（<code>test_and_set</code>）：获取旧数值并设置新数值</li><li>比较并交换（<code>compare_and_swap</code>）：比较数值是否符合预期，是则更新值，返回旧数值</li><li>总线锁：多CPU下，总线锁阻止其它CPU访问数据</li><li>缓存锁：通过缓存一致性协议保证CPU缓存中的数值都是相同的</li></ul></li><li>同步机制： <ul><li>临界区（开关中断）</li><li>信号量</li><li>互斥（同时只能有一个访问）与同步（按照一定的制约顺序执行）</li><li>管程（利用条件变量）</li></ul></li><li>典型的锁： <ul><li>读写锁：多个读者可以同时读，同时只能有一个写者（有写者时不能有读者），写者优先级高于读者</li><li>互斥锁：同时只能有一人访问资源</li><li>条件变量：根据某个条件判断是否解除互斥，是互斥锁的补全（同步）</li><li>自旋锁：如果无法取得，则原地自旋（<code>while</code>），直到能够进入，利用进程切换，会导致时间片浪费，适用于上锁时间短的情况</li><li>RCU（内核同步）：在读者完成了对资源的读取后，写者就可以安全地修改资源，因此要确定这个所有读者均完成读取的“宽限期”。RCU使用前禁止抢占，在临界区内禁止调度，因为禁止调度，如果发生了调度，说明在某个CPU上，对该对象的读取已经完成，所有CPU均调度完成时，旧对象则没有任何引用了，此时可以安全覆盖旧对象。</li></ul></li><li>POSIX同步机制： <ul><li>POSIX信号量：进程/线程同步</li><li>POSIX互斥锁，条件变量：线程同步</li></ul></li><li>线程终端退出：<code>tty</code>退出时会发送<code>SIGHUP</code>给命令行，命令行会捕捉该命令并转发给子进程，如果不做处理，进程会退出</li></ul><h2 id="内存管理" tabindex="-1"><a class="header-anchor" href="#内存管理"><span>内存管理</span></a></h2><ul><li><p>内存：一块高速的易失性存储，程序和数据需要加载到内存中才能被CPU读取和执行，（我认为其目的是充当硬盘和CPU之间的一层缓冲，加速程序（程序执行流和数据访问）的执行。假设没有内存，CPU在执行每条指令，获取任何数据前都需要先访问硬盘获取指令或者数据，其中的时间消耗是无法忍受的）</p></li><li><p>虚拟内存（页表实现）：多级页表为每个进程引入了超大的虚拟空间，让每个进程都能够使用完整的地址范围（间接提升了进程的可移植性，因为不需要固定编址）。同时，页表是分页对内存进行管理、其中的虚拟内存物理上不必相连，甚至不一定在物理内存中，可以通过缺页机制，仅当我们需要该页面时才将内存加载进入物理内存，达到使用有限的内存运行大内存程序</p></li><li><p>快表加持的地址转换：CPU给出逻辑地址，<code>MMU</code>先查<code>TLB</code>是否有对应页号，如果有则直接组合物理地址，否则爬多级页表进行转换，并记录在快表中</p></li><li><p>内存覆盖：把用户空间分为固定区和覆盖区，将活跃的部分放入固定区，其他部分按照调用关系分段，将即将要访问的放在覆盖区，其他放在外存，在需要调用前，将其换入覆盖区，替换原有段</p></li><li><p>内存交换（换入换出）：</p><ul><li>换出：将处于等待（暂时不会运行的进程）换出到辅存，把内存空间腾出来</li><li>换入：把准备好竞争的进程从辅存移入内存</li></ul></li><li><p>换页算法：</p><ul><li>最佳置换法（OPT）：每次淘汰的页面是最长时间内不再访问的页面（不可能实现）</li><li>先进先出（FIFO）：最早进入的页面最早淘汰</li><li>最近最久未使用（LRU）：记录页面的自上次被访问以来所经历的时间，淘汰时，选择页面中时间最大的</li><li>时钟置换算法（CLOCK）：将页面链接为链表，置访问位,当要淘汰页面时遍历该表，如果未访问则换出，若访问过则清空访问位，继续检查下一个，如果没找到则进行第二轮扫描</li><li>改进时钟置换：添加访问位和修改位：第一轮遇到(0,0)换出；第二轮找(0,1)，访问置0；第三轮找(0,0)；第四轮找(0,1)</li></ul></li><li><p>内部碎片和外部碎片：</p><ul><li>内部碎片：分配器只能分配固定大小的内存，由于需求内存的大小不一致而产生的空间浪费</li><li>外部碎片：内存的申请和释放导致内存中出现小空闲区，无法被利用</li></ul></li><li><p>内存空间（从高到低）：</p><table><thead><tr><th>区域</th><th>内容</th></tr></thead><tbody><tr><td>内核</td><td>控制程序执行的操作系统功能</td></tr><tr><td>栈</td><td>环境变量、argv、argc、main函数的局部变量，其他函数的局部变量（向下增长）</td></tr><tr><td>闲置</td><td>栈的增长空间</td></tr><tr><td>共享内存</td><td>动态链接库、用户映射等</td></tr><tr><td>闲置</td><td>堆的增长空间</td></tr><tr><td>堆</td><td>需要申请的大内存空间（向上增长）</td></tr><tr><td>数据段</td><td>初始化数据，未初始化数据</td></tr><tr><td>代码段</td><td>静态链接库函数、其他程序函数、main函数、启动例程（crt0.o）</td></tr></tbody></table></li><li><p>glibc内存池（<code>ptmalloc</code>）：</p><ul><li><code>ptmalloc</code>以<code>chunk</code>组织内存</li><li>每个进程都有一个<code>main_arena</code>和若干个<code>non_main_arena</code>，采用环形链表管理，<code>main_arena</code>能够使用<code>brk</code>和<code>mmap</code>，<code>non_main_arena</code>只能使用<code>mmap</code>（那次申请64MB，切块交给用户），申请内存时，如果线程当前拥有一个<code>arena</code>，会从中进行分配，如果失败（被占用）则在链表中循环，如果没有空闲<code>arena</code>，则创建新的</li><li>使用<code>mmap</code>申请的内存用完后直接还给操作系统</li><li>主分配区上，判断申请大小是否超过<code>DEFAULT_MMAP_THRESHOLD</code>决定是否使用mmap,一般是128KB，小于这个值则使用<code>sbrk</code></li><li>返还的内存被记录在名为<code>bins</code>的结构中： <ul><li><code>bins</code>：长128的数组，每个元素都是一个双向链表</li><li><code>unsorted_bin</code>（<code>bins[1]</code>）：维护<code>free</code>释放的<code>chunk</code></li><li><code>small_bins</code>（<code>bins[2,63]</code>）：维护小于512字节的内存块，<code>chunk</code>大小为<code>index * 8</code></li><li><code>large_bins</code>（<code>bins[64,127]</code>）：维护大于512字节的内存块，<code>index</code>越大，<code>chunk</code>大小相差越大</li><li><code>fast_bins</code>：不大于<code>max_fast(128B)</code>的<code>chunk</code>释放后，会被放到<code>fast_bins</code>中，当需要小内存时，他们会被优先分配，某个特定时候，<code>fast_bins</code>会尝试合并，并放入<code>unsorted_bin</code>中</li><li>申请内存会先查找<code>fast_bins</code>，再尝试从<code>unsorted_bin</code>中查找，如果<code>chunk</code>不能满足需求，则将其放入合适的<code>bin</code>中，否则切块交给用户</li></ul></li><li>当<code>bins</code>无法满足需求时，会在<code>top_chunk</code>中分配内存（堆最上面的空间），剩余的部分形成新的<code>top_chunk</code></li><li><code>mmaped_chunk</code>是由<code>mmap</code>分配的<code>chunk</code>,它们用完后直接还给操作系统</li></ul></li></ul><h2 id="中断" tabindex="-1"><a class="header-anchor" href="#中断"><span>中断</span></a></h2><ul><li>硬件中断：外部硬件与CPU和内核交互 <ul><li>上半中断：中断服务函数</li><li>下半中断： <ul><li>软中断：编译期分配好，不可更改，最多有32个软中断，目前只有网络和SCSI直接使用软中断</li><li><code>tasklet</code>：使用两类软中断<code>HI_SOFTIRQ</code>和<code>TASKLET_SOFTIRQ</code>，可以动态增减，同类<code>tasklet</code>不能并发执行</li><li>工作队列：利用内核线程执行，可以睡眠和阻塞</li></ul></li></ul></li><li>软件中断：异常、系统调用</li></ul><h2 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章"><span>参考文章</span></a></h2><p><a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/02-01-os.html" target="_blank" rel="noopener noreferrer">阿秀的学习笔记-操作系统</a></p>',9)]))}const n=t(o,[["render",c]]),s=JSON.parse('{"path":"/article/t7r0wnef/","title":"秋招面经笔记-操作系统&Linux串烧","lang":"zh-CN","frontmatter":{"title":"秋招面经笔记-操作系统&Linux串烧","createTime":"2025/08/09 12:37:10","permalink":"/article/t7r0wnef/","tags":["OS","Linux"],"description":"进程、线程与协程 Linux线程：轻量级的进程，与进程同样以task_struct结构体的形式保存，线程栈的大小默认是8M，最大线程数一般受制于虚拟空间大小 线程回收： 等待线程结束（pthread_join） 直接结束线程（pthread_exit），分离 让线程自己管理自己的资源（pthread_detach） 进程的创建（fork）：内部调用ke...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"秋招面经笔记-操作系统&Linux串烧\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-08T11:03:23.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://dessera.github.io/article/t7r0wnef/"}],["meta",{"property":"og:site_name","content":"Dessera Lab"}],["meta",{"property":"og:title","content":"秋招面经笔记-操作系统&Linux串烧"}],["meta",{"property":"og:description","content":"进程、线程与协程 Linux线程：轻量级的进程，与进程同样以task_struct结构体的形式保存，线程栈的大小默认是8M，最大线程数一般受制于虚拟空间大小 线程回收： 等待线程结束（pthread_join） 直接结束线程（pthread_exit），分离 让线程自己管理自己的资源（pthread_detach） 进程的创建（fork）：内部调用ke..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-08T11:03:23.000Z"}],["meta",{"property":"article:tag","content":"Linux"}],["meta",{"property":"article:tag","content":"OS"}],["meta",{"property":"article:modified_time","content":"2025-10-08T11:03:23.000Z"}]]},"readingTime":{"minutes":10.23,"words":3069},"git":{"createdTime":1754805919000,"updatedTime":1759921403000,"contributors":[{"name":"Dessera","username":"Dessera","email":"dessera@qq.com","commits":4,"avatar":"https://avatars.githubusercontent.com/Dessera?v=4","url":"https://github.com/Dessera"}],"changelog":[{"hash":"8822e76d8d2b38cdc55efc7d8980256c70213d4a","time":1759921403000,"email":"dessera@qq.com","author":"Dessera","message":"MNN01"},{"hash":"f408ee9eeb1b8de1237ff1d0bc19db2762e33eb3","time":1754805973000,"email":"dessera@qq.com","author":"Dessera","message":"修复命名"},{"hash":"003070fcc2a08f96777c5e2dc2bbe1d521becf95","time":1754805951000,"email":"dessera@qq.com","author":"Dessera","message":"参考文章"},{"hash":"e854cc48d63365d10f9afbb3b66ff4053bf5bdd3","time":1754805919000,"email":"dessera@qq.com","author":"Dessera","message":"秋招笔记"}]},"autoDesc":true,"filePathRelative":"笔记/秋招面经笔记-操作系统&Linux串烧.md","headers":[],"categoryList":[{"id":"7051dc","sort":10000,"name":"笔记"}]}');export{n as comp,s as data};
