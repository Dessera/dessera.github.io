import{_ as a,c as s,a as n,o}from"./app-BYecpAAQ.js";const t={};function c(i,e){return o(),s("div",null,e[0]||(e[0]=[n(`<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>笔者上个月受到朋友激励，决心通过<strong>自己编写</strong>操作系统内核来学习操作系统，截至本文起稿，笔者已经初步完成了内核态的实现，故将相关内容总结为系列文章，聊表纪念。</p><p>我们的计算机生活离不开操作系统，现如今，我们如同呼吸一般理所当然的使用Windows、Linux、macOS等操作系统，然而，鲜少有人关注到这些操作系统背后的原理。想要了解操作系统的幕后工作，我们就必须知道它的职责，这时，我们自然而然地会引出一个疑问——<strong>操作系统在计算机中扮演者什么样的角色？</strong></p><p>对于特定的<strong>用户任务</strong>来说，它并不关心自己的内存从哪里来、自己需要的数据如何从外部设备中传入、自己如何与其他程序共享CPU时间，它应当只关心自己的业务逻辑。但很不幸的是，在<strong>裸机</strong>编程中没有人为他管理这些资源，用户不得不亲手管理这些资源，这虽然有可能能够达到最佳的性能，但无疑增加了开发难度，降低了开发效率。</p><p>我们可以认为操作系统是一个资源代理，用户进程不需要关系自己的资源从哪里来，如何分配，它只需要在需要时向操作系统<strong>申请</strong>资源。这里的资源包括计算机能够提供的各种资源，如内存、CPU、硬盘、网络等。从这个角度来说，操作系统就是一个<strong>资源管理器</strong>，其目的是为所有用户进程提供清晰的资源抽象。</p><h2 id="操作系统职责" tabindex="-1"><a class="header-anchor" href="#操作系统职责"><span>操作系统职责</span></a></h2><p>想象一下，我们现在要实现一个最小操作系统，第一步一定是要列出我们的<strong>TODOS</strong>，问题来了，我们都需要完成什么？</p><p>我们知道操作系统是一个资源管理器，那么，为了管理这些资源，我们最起码要完成以下任务：</p><ol><li><strong>中断管理</strong>：中断是CPU响应事件的机制，操作系统需要管理中断以实现任务调度、异常处理、系统调用和设备驱动等功能。</li><li><strong>内存管理</strong>：内存是计算机中的稀缺资源（相比硬盘来说），操作系统需要管理内存以实现高效的内存分配和回收。</li><li><strong>任务管理</strong>：单核CPU中，理论上同时只能运行一个程序，操作系统需要通过任务调度实现多个程序“同时运行”。</li><li><strong>文件系统</strong>：硬盘容量虽然比内存要大，但其存储的内容也比内存要多，操作系统需要实现文件系统以合理地管理硬盘资源。</li></ol><blockquote><p>至于网络管理，这是另一个宏大的话题，我们暂时不讨论。</p></blockquote><h2 id="操作系统的启动" tabindex="-1"><a class="header-anchor" href="#操作系统的启动"><span>操作系统的启动</span></a></h2><p>我们知道了我们都需要实现什么功能模块，但我们仍然有一个问题，计算机启动时是如何进入操作系统的？</p><p>在<code>i386</code>架构中，计算机复位时会在<code>CS:IP</code>中装入固定的数据，无论如何，最终都会导向一个固定的地址<code>0xffff0</code>，这个地址包含了如下指令：</p><blockquote><p>在Intel手册中，<code>CS:IP</code>复位后的值为<code>0xf000:0xfff0</code>，但在一些非标准架构中可能有所不同，但无论如何，最终都会导向<code>0xffff0</code>。</p></blockquote><div class="language-plaintext line-numbers-mode" data-highlighter="shiki" data-ext="plaintext" style="--shiki-dark:#abb2bf;--shiki-light:#383A42;--shiki-dark-bg:#282c34;--shiki-light-bg:#FAFAFA;"><pre class="shiki shiki-themes one-dark-pro one-light vp-code"><code class="language-plaintext"><span class="line"><span>ea 5b e0 00 f0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这实际是一条<code>ljmp</code>指令，它将跳转至<code>0xf000:0xe05b</code>，这个地址是<code>BIOS</code>的入口地址。</p><p>等等，说了这么多，我们没有解决一个问题——<strong>BIOS是什么？</strong></p><h3 id="basic-input-output-system-bios" tabindex="-1"><a class="header-anchor" href="#basic-input-output-system-bios"><span>Basic Input/Output System （BIOS）</span></a></h3><p><code>BIOS</code>是计算机启动时首先加载的程序，它是我们操作系统的<strong>跳板</strong>，在操作系统启动之前，负责初始化一些操作系统启动需要的硬件资源，包括显示接口、硬盘接口等。</p><p>同时，<code>BIOS</code>还负责我们操作系统的启动，它将我们的操作系统的第一个扇区（通常称为<code>MBR</code>，前<code>0x200</code>字节）加载至内存，并跳转至该扇区的入口地址。</p><p>在实模式中，我们能够操作的内存空间只有<code>1MB</code>，下面是实模式的内存布局：</p><div class="language-plaintext line-numbers-mode" data-highlighter="shiki" data-ext="plaintext" style="--shiki-dark:#abb2bf;--shiki-light:#383A42;--shiki-dark-bg:#282c34;--shiki-light-bg:#FAFAFA;"><pre class="shiki shiki-themes one-dark-pro one-light vp-code"><code class="language-plaintext"><span class="line"><span>0x00000 - 0x003ff : BIOS 中断向量表</span></span>
<span class="line"><span>0x00400 - 0x004ff : BIOS 数据区</span></span>
<span class="line"><span>0x00500 - 0x07bff : 可用内存</span></span>
<span class="line"><span>0x07c00 - 0x07dff : MBR扇区</span></span>
<span class="line"><span>0x07e00 - 0x9fbff : 可用内存</span></span>
<span class="line"><span>0x9fc00 - 0x9ffff : BIOS 扩展数据区</span></span>
<span class="line"><span>0xa0000 - 0xaffff : 用于彩色显示适配器</span></span>
<span class="line"><span>0xb0000 - 0xb7fff : 用于黑白显示适配器</span></span>
<span class="line"><span>0xb8000 - 0xbffff : 用于文本显示适配器</span></span>
<span class="line"><span>0xc0000 - 0xc7fff : 显示适配器BIOS</span></span>
<span class="line"><span>0xc8000 - 0xeffff : 映射硬件适配器的 ROM 或内存映射式 I/O</span></span>
<span class="line"><span>0xf0000 - 0xfffff : 系统 BIOS</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从图中我们可以知道，<code>MBR</code>会被加载至<code>0x7c00</code>。</p><h3 id="mbr" tabindex="-1"><a class="header-anchor" href="#mbr"><span>MBR</span></a></h3><p><code>BIOS</code>会检查所有存储器的第一个扇区，如果第一个扇区的前<code>0x200</code>字节符合<code>MBR</code>格式，则将其加载至内存，并跳转至<code>0x7c00</code>。</p><p>一个<code>MBR</code>扇区由其最后两个字节标识，这两个字节必须为<code>0x55aa</code>，否则<code>BIOS</code>会认为该扇区不是<code>MBR</code>，<code>BIOS</code>会检查所有硬盘，并找到第一个符合<code>MBR</code>格式的扇区进行引导。</p><blockquote><p>实际上读者会发现，这样的启动流程是及其简陋的，在这种环境下，双系统甚至多系统引导是及其困难的（即便一些现代的BIOS支持）。因此，现代的操作系统通常使用<code>multiboot</code>协议来引导，<code>MBR</code>只负责引导一个<strong>引导程序</strong>（例如<code>GRUB</code>），引导程序再通过<code>multiboot</code>协议引导操作系统。</p></blockquote><h2 id="我们的工作" tabindex="-1"><a class="header-anchor" href="#我们的工作"><span>我们的工作</span></a></h2><p>从上文我们了解了操作系统的职责和引导流程，我们很容易就能总结出我们这一阶段的工作：</p><ol><li><strong>实现引导程序</strong>：实现<code>MBR</code>和<code>loader</code>，引导操作系统内核。</li><li><strong>实现操作系统内核</strong>：实现我们上面提到的中断、内存、任务、文件系统等模块。</li></ol><p>从下一章开始，我们会依序实现这两个部分。</p><h2 id="工具链" tabindex="-1"><a class="header-anchor" href="#工具链"><span>工具链</span></a></h2><p>很抱歉我们直到最后才提到工具链，因为笔者认为，对于导论来说，工具链是最不重要的那部分，但对于工程来说，工具链的一致性是一切的前提，因此，你必须确保系统中安装了以下工具：</p><ul><li><code>gcc</code>：用于<code>C/ASM</code>源文件的编译，支持<code>GNU C Extension</code>和<code>c23</code>标准</li><li><code>gdb</code>：用于调试</li><li><code>make</code>：任意<code>Makefile</code>实现，用于工程管理</li><li><code>qemu-system-i386</code>：用于运行虚拟机</li></ul><h3 id="nix" tabindex="-1"><a class="header-anchor" href="#nix"><span>Nix</span></a></h3><p>如果读者使用的发行版是<code>NixOS</code>，或者任何安装了<code>Nix</code>包管理器的系统，那么你可以使用笔者提前准备好的<code>flake</code>来安装这些工具，详见仓库<a href="https://github.com/Dessera/OrdOS" target="_blank" rel="noopener noreferrer">Ordos</a>，这也是笔者目前的内核代码仓库。</p><h2 id="鸣谢" tabindex="-1"><a class="header-anchor" href="#鸣谢"><span>鸣谢</span></a></h2><p>感谢<a href="https://www.charliechen114514.tech" target="_blank" rel="noopener noreferrer">Charliechen114514</a>对笔者提供的一切帮助，欢迎阅读由他编写的<a href="https://github.com/Charliechen114514/CCOperateSystem" target="_blank" rel="noopener noreferrer">CCOperateSystem</a>，这是一份非常优秀的操作系统实现，并且有丰富的文档支持。</p><p>感谢项目<a href="https://github.com/chobits/tinyos" target="_blank" rel="noopener noreferrer">tinyos</a>，笔者从中参考了内存管理实现。</p>`,39)]))}const d=a(t,[["render",c]]),p=JSON.parse('{"path":"/oslab/67uw426e/","title":"文章简介","lang":"zh-CN","frontmatter":{"title":"文章简介","createTime":"2025/03/15 11:44:34","permalink":"/oslab/67uw426e/","tags":["操作系统","C","ASM","x86"],"description":"前言 笔者上个月受到朋友激励，决心通过自己编写操作系统内核来学习操作系统，截至本文起稿，笔者已经初步完成了内核态的实现，故将相关内容总结为系列文章，聊表纪念。 我们的计算机生活离不开操作系统，现如今，我们如同呼吸一般理所当然的使用Windows、Linux、macOS等操作系统，然而，鲜少有人关注到这些操作系统背后的原理。想要了解操作系统的幕后工作，我...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"文章简介\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-19T16:16:12.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://dessera.github.io/oslab/67uw426e/"}],["meta",{"property":"og:site_name","content":"Dessera Lab"}],["meta",{"property":"og:title","content":"文章简介"}],["meta",{"property":"og:description","content":"前言 笔者上个月受到朋友激励，决心通过自己编写操作系统内核来学习操作系统，截至本文起稿，笔者已经初步完成了内核态的实现，故将相关内容总结为系列文章，聊表纪念。 我们的计算机生活离不开操作系统，现如今，我们如同呼吸一般理所当然的使用Windows、Linux、macOS等操作系统，然而，鲜少有人关注到这些操作系统背后的原理。想要了解操作系统的幕后工作，我..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-19T16:16:12.000Z"}],["meta",{"property":"article:tag","content":"x86"}],["meta",{"property":"article:tag","content":"ASM"}],["meta",{"property":"article:tag","content":"C"}],["meta",{"property":"article:tag","content":"操作系统"}],["meta",{"property":"article:modified_time","content":"2025-03-19T16:16:12.000Z"}]]},"readingTime":{"minutes":6.15,"words":1845},"git":{"createdTime":1742016837000,"updatedTime":1742400972000,"contributors":[{"name":"Dessera","username":"Dessera","email":"dessera@qq.com","commits":3,"avatar":"https://avatars.githubusercontent.com/Dessera?v=4","url":"https://github.com/Dessera"}],"changelog":[{"hash":"328913c6993e8b1b5aff6136565b0d63764dc91d","time":1742400972000,"email":"dessera@qq.com","author":"Dessera","message":"[WIP]伙伴系统"},{"hash":"464dc840a33857cf9fa0101f1ddbc5dd9ad6ecf4","time":1742392174000,"email":"dessera@qq.com","author":"Dessera","message":"更新oslab文章简介"},{"hash":"bbed312f14cfce0f089566368f673cd4f6c92392","time":1742016837000,"email":"dessera@qq.com","author":"Dessera","message":"oslab文章简介"}]},"autoDesc":true,"filePathRelative":"notes/oslab/文章简介.md","headers":[]}');export{d as comp,p as data};
